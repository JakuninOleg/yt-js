class Component {
	constructor() {
		if (new.target === Component) {
			throw new Error(`Can't instantiate Component, only concrete one.`);
		}
	}

	get template() {
		throw new Error(`You have to define template.`);
  }

  // Данный метод является геттером и должен возвращать значение template инстанса класса Component, однако, данный метод может лишь сигнализировать об ошибке.Причем ошибка будет возникать при каждом вызове данной функции, т.к. отсутствует логический оператор. Для верной работы метода необходимо добавить строку return this._template и логику (когда должна быть вызван ошибка). Подробнее об исключениях - https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/throw

	static createElement(template) {
		const createNewTag = document.createElement(`div`);
		createNewTag.innerHTML = template;
		return createNewTag.firstChild;
  }

  // Не совсем ясна логика создания статичного метода. Данный метод не будет доступен экземплярам класса и должен быть использован для создания вспомогательного функционала приложения. Логичнее будет логику создания компонента перенести в конструктор класса. Если был выбран фабричный подход к созданию экземпляра класса, можно было бы использовать следующее выражение в теле функции - return new Сomponent();

	render() {
		this._element = Component.createElement(this.template);
		this.setEventListener();
		return this._element;
  }

  // Для лучшей читаемости кода - следует оставлять пустую строку перед другим методом.
  // В данном методе используется обращение к переменной element с нижним подчеркиванем. Логичнее перенести создание переменной в конструктор класса, а для реализации сокрытия данных использовать сеттеры и геттеры. Подробнее об ООП и дескрипторах в современном JS - https://coryrylan.com/blog/javascript-es6-class-syntax
  // Функции render исходя из логики названия должна отображать компонент на странице пользователя, однако здесь первым действием создается элемент, логика этого действия должна отправляться в конструктор класса.

	removeItem() {
		this.removeEventListener();
		this._element.remove();
		this._element = null;
	}

	setEventListener() {}
  removeEventListener() {}

  // У класса есть два пустых метода, которые никак не описаны. Судя по неймингу - данные методы должен добавлять и убирать отслеживания события. Хорошей практикой является создание небольших методов с понятным описанием, однако, в данном случае данный функционал не внедрен до конца. Необходимо перенести логику создания и удаления отслеживания события в соответствующие методы.

}
